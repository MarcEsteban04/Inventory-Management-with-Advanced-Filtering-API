================================================================================
INVENTORY MANAGEMENT API - COMPLETE CODE EXPLANATION
================================================================================

This document explains every component of the Inventory Management API system
to help you understand and explain your code during assessment.

================================================================================
1. PROJECT STRUCTURE & ARCHITECTURE
================================================================================

The system follows a clean, layered architecture:

├── server.js           # Main Express server entry point
├── database.js         # Database connection configuration
├── knexfile.js         # Knex.js database configuration
├── package.json        # Dependencies and npm scripts
├── routes/
│   ├── products.js     # Product-related API endpoints
│   └── tags.js         # Tag-related API endpoints
├── migrations/         # Database schema definitions
├── seeds/             # Sample data for testing
└── README.md          # Documentation

WHY THIS STRUCTURE?
- Separation of concerns: Each file has a specific responsibility
- Scalability: Easy to add new routes and features
- Maintainability: Clear organization makes debugging easier
- Professional standard: Follows Node.js best practices

================================================================================
2. DATABASE DESIGN & NORMALIZATION
================================================================================

TABLES CREATED:
1. products        - Core product information
2. tags           - Product categorization tags
3. product_tags   - Junction table (many-to-many relationship)
4. inventory      - Stock movement tracking

RELATIONSHIPS EXPLAINED:
- Products ↔ Tags: Many-to-Many (one product can have multiple tags, one tag can be on multiple products)
- Products → Inventory: One-to-Many (one product can have multiple inventory records)

WHY THIS DESIGN?
- Normalization: Eliminates data redundancy
- Flexibility: Easy to add/remove tags without affecting products
- Audit trail: Inventory table tracks all stock movements
- Performance: Proper indexes for fast queries

CURRENT_STOCK COLUMN:
- Computed/maintained column in products table
- Updated atomically when inventory changes
- Avoids expensive calculations on every read
- Ensures data consistency through transactions

================================================================================
3. KEY FILES EXPLAINED
================================================================================

3.1 SERVER.JS - Main Application Entry Point
-------------------------------------------
PURPOSE: Sets up the Express server and middleware

KEY COMPONENTS:
- Express.js framework setup
- Security middleware (Helmet, CORS)
- Logging middleware (Morgan)
- Route handlers mounting
- Error handling middleware
- Health check endpoint

MIDDLEWARE EXPLAINED:
- helmet(): Adds security headers to protect against common attacks
- cors(): Enables Cross-Origin Resource Sharing for frontend integration
- morgan(): Logs HTTP requests for debugging and monitoring
- express.json(): Parses JSON request bodies

ERROR HANDLING:
- Global error handler catches all unhandled errors
- Returns appropriate HTTP status codes
- Hides sensitive error details in production

3.2 DATABASE.JS - Database Connection
------------------------------------
PURPOSE: Establishes connection to PostgreSQL database

HOW IT WORKS:
- Imports Knex configuration from knexfile.js
- Determines environment (development/production)
- Creates database connection instance
- Exports connection for use in routes

WHY SEPARATE FILE?
- Single point of database configuration
- Easy to modify connection settings
- Reusable across all route files

3.3 KNEXFILE.JS - Database Configuration
---------------------------------------
PURPOSE: Configures Knex.js query builder and migrations

ENVIRONMENTS:
- Development: Local PostgreSQL setup
- Production: Production database with SSL

CONFIGURATION INCLUDES:
- Database connection parameters
- Migration directory location
- Seed data directory location

WHY KNEX.JS?
- Query builder provides SQL injection protection
- Database-agnostic (can switch from PostgreSQL to MySQL easily)
- Migration system for version control of database schema
- Connection pooling for performance

================================================================================
4. MIGRATION FILES EXPLAINED
================================================================================

4.1 CREATE_PRODUCTS_TABLE.JS
----------------------------
CREATES: products table with columns:
- id: Primary key (auto-incrementing)
- name: Product name (required, indexed for search performance)
- description: Product description (optional)
- price: Product price (decimal with 2 decimal places)
- current_stock: Current inventory count (indexed for filtering)
- created_at/updated_at: Timestamps

INDEXES EXPLAINED:
- name index: Fast searching by product name
- current_stock index: Fast filtering by stock levels

4.2 CREATE_TAGS_TABLE.JS
------------------------
CREATES: tags table with columns:
- id: Primary key
- name: Tag name (unique constraint prevents duplicates)
- description: Tag description
- timestamps

UNIQUE CONSTRAINT:
- Prevents duplicate tag names
- Ensures data integrity

4.3 CREATE_PRODUCT_TAGS_TABLE.JS
-------------------------------
CREATES: Junction table for many-to-many relationship
- id: Primary key
- product_id: Foreign key to products table
- tag_id: Foreign key to tags table
- timestamps

FOREIGN KEY CONSTRAINTS:
- CASCADE DELETE: When product/tag is deleted, relationships are automatically removed
- Maintains referential integrity

UNIQUE CONSTRAINT:
- Prevents duplicate product-tag relationships
- Ensures each product-tag pair exists only once

4.4 CREATE_INVENTORY_TABLE.JS
----------------------------
CREATES: inventory table for stock tracking
- id: Primary key
- product_id: Foreign key to products table
- type: ENUM ('in' or 'out') for stock movement direction
- quantity: Amount of stock moved
- reason: Optional explanation for the movement
- timestamps

WHY SEPARATE INVENTORY TABLE?
- Audit trail: Track all stock movements
- Historical data: Know when and why stock changed
- Compliance: Required for business auditing
- Debugging: Easy to trace stock discrepancies

================================================================================
5. SEED FILES EXPLAINED
================================================================================

PURPOSE: Populate database with sample data for testing

EXECUTION ORDER:
1. 01_tags.js - Creates sample tags first (no dependencies)
2. 02_products.js - Creates sample products
3. 03_product_tags.js - Links products to tags (depends on both existing)
4. 04_inventory.js - Creates initial stock movements

WHY THIS ORDER?
- Foreign key dependencies require parent records to exist first
- Tags must exist before product-tag relationships
- Products must exist before inventory records

SAMPLE DATA INCLUDES:
- Electronics: iPhone, Samsung Watch, MacBook
- Footwear: Nike shoes, Adidas shoes
- Clothing: Levi's jeans
- Various tags: Electronics, Footwear, Premium, Sale

================================================================================
6. ROUTES EXPLAINED
================================================================================

6.1 PRODUCTS.JS - Product Management Routes
------------------------------------------

GET /api/products - List all products with filtering
LOGIC:
1. Extract query parameters (tag, min_stock, name)
2. Build base query with LEFT JOINs to get tags
3. Apply filters conditionally
4. Use array_agg() to collect tags into array
5. Return products with their associated tags

ADVANCED FILTERING:
- Tag filtering: Uses subquery to find products with specific tags
- Stock filtering: WHERE clause on current_stock column
- Name search: Case-insensitive ILIKE for partial matching
- Combined filters: All can be used together

WHY ARRAY_AGG instead of JSON_AGG?
- Better PostgreSQL compatibility
- Simpler data structure
- Avoids JSON operator issues

GET /api/products/:id - Get single product
LOGIC:
1. Query product by ID with LEFT JOINs
2. Aggregate tags into array
3. Return 404 if product not found
4. Return complete product data with tags

POST /api/products - Create new product
TRANSACTION LOGIC:
1. Start database transaction
2. Validate input data (name, price required)
3. Create product record
4. Handle tag assignment:
   - Find existing tags
   - Create new tags if needed
   - Create product-tag relationships
5. Create initial inventory record if stock > 0
6. Commit transaction or rollback on error

WHY TRANSACTIONS?
- Ensures all operations succeed or fail together
- Prevents partial data corruption
- Maintains database consistency

PATCH /api/products/:id - Update product
LOGIC:
1. Check if product exists
2. Validate input data
3. Update only provided fields
4. Exclude stock and tags (as per requirements)
5. Return updated product with tags

DELETE /api/products/:id - Delete product
TRANSACTION LOGIC:
1. Start transaction
2. Check if product exists
3. Delete associated records (inventory, product_tags)
4. Delete product record
5. Commit transaction

CASCADE DELETE:
- Foreign key constraints automatically handle related records
- Explicit deletion for clarity and control

POST /api/products/:id/stock - Inventory management
CRITICAL TRANSACTION:
1. Start transaction
2. Validate input (type: 'in'/'out', quantity > 0)
3. Get current product stock
4. Calculate new stock level
5. Prevent negative stock (business rule)
6. Create inventory record
7. Update product current_stock atomically
8. Commit or rollback

ATOMICITY EXPLAINED:
- Both inventory record and stock update happen together
- If either fails, both are rolled back
- Prevents data inconsistency
- Critical for business operations

6.2 TAGS.JS - Tag Management Routes
----------------------------------

GET /api/tags - List all tags
SIMPLE QUERY:
- Returns all tags ordered by name
- No complex joins needed

GET /api/tags/:id - Get single tag with products
LOGIC:
1. Get tag details
2. Get associated products via JOIN
3. Return tag with product list

POST /api/tags - Create new tag
VALIDATION:
- Name is required
- Handles unique constraint violations
- Returns appropriate error messages

PATCH /api/tags/:id - Update tag
LOGIC:
- Similar to product update
- Handles unique constraint on name

DELETE /api/tags/:id - Delete tag
TRANSACTION:
- Removes product-tag relationships first
- Then deletes tag
- Maintains referential integrity

================================================================================
7. ERROR HANDLING STRATEGY
================================================================================

HTTP STATUS CODES USED:
- 200: Success (GET requests)
- 201: Created (POST requests)
- 400: Bad Request (validation errors)
- 404: Not Found (resource doesn't exist)
- 409: Conflict (duplicate entries)
- 500: Internal Server Error (unexpected errors)

ERROR RESPONSE FORMAT:
{
  "success": false,
  "error": "Error category",
  "message": "Detailed explanation"
}

VALIDATION ERRORS:
- Required fields missing
- Invalid data types
- Business rule violations (negative stock)

DATABASE ERRORS:
- Unique constraint violations
- Foreign key constraint violations
- Connection errors

WHY CONSISTENT ERROR FORMAT?
- Frontend can handle errors uniformly
- Clear debugging information
- Professional API design

================================================================================
8. SECURITY MEASURES
================================================================================

SQL INJECTION PREVENTION:
- Knex.js parameterized queries
- No raw SQL string concatenation
- Input validation and sanitization

SECURITY HEADERS:
- Helmet.js adds security headers
- Prevents common web vulnerabilities
- XSS protection, content type sniffing prevention

CORS CONFIGURATION:
- Controlled cross-origin access
- Prevents unauthorized frontend access

INPUT VALIDATION:
- Type checking (numbers, strings)
- Range validation (positive quantities)
- Required field validation

================================================================================
9. PERFORMANCE OPTIMIZATIONS
================================================================================

DATABASE INDEXES:
- Primary keys for fast lookups
- Foreign key indexes for JOIN performance
- name and current_stock indexes for filtering

QUERY OPTIMIZATION:
- Efficient JOINs instead of multiple queries
- Aggregation at database level (array_agg)
- Conditional query building (only apply needed filters)

CONNECTION POOLING:
- Knex.js handles connection pooling automatically
- Reuses database connections
- Prevents connection exhaustion

TRANSACTION EFFICIENCY:
- Short transaction duration
- Rollback on any failure
- Minimal lock time

================================================================================
10. BUSINESS LOGIC IMPLEMENTATION
================================================================================

INVENTORY MANAGEMENT:
- Stock movements tracked in separate table
- Current stock maintained for performance
- Prevents overselling (negative stock check)
- Audit trail for compliance

PRODUCT-TAG RELATIONSHIPS:
- Flexible tagging system
- Many-to-many relationship allows complex categorization
- Easy to add/remove tags without affecting products

ADVANCED FILTERING:
- Multiple filter combinations
- Case-insensitive search
- Efficient database queries
- RESTful query parameter design

================================================================================
11. API DESIGN PRINCIPLES
================================================================================

RESTful DESIGN:
- HTTP verbs match operations (GET, POST, PATCH, DELETE)
- Resource-based URLs (/api/products, /api/tags)
- Consistent response format
- Appropriate status codes

ENDPOINT DESIGN:
- /api/products - Collection operations
- /api/products/:id - Individual resource operations
- /api/products/:id/stock - Sub-resource operations

RESPONSE CONSISTENCY:
- Always include "success" field
- Consistent data structure
- Meaningful error messages
- Appropriate HTTP status codes

================================================================================
12. TESTING STRATEGY
================================================================================

MANUAL TESTING:
- Browser testing for GET endpoints
- Postman collection for all operations
- Health check endpoint for monitoring

TEST SCENARIOS:
- CRUD operations for all resources
- Advanced filtering combinations
- Error conditions (invalid data, not found)
- Transaction rollback scenarios

SAMPLE DATA:
- Realistic product catalog
- Various tag categories
- Initial inventory movements
- Edge cases (zero stock, high stock)

================================================================================
13. DEPLOYMENT CONSIDERATIONS
================================================================================

ENVIRONMENT CONFIGURATION:
- .env file for sensitive data
- Different configs for dev/production
- Database connection parameters
- Port configuration

PRODUCTION READINESS:
- Error logging and monitoring
- Security headers
- Connection pooling
- Transaction management

SCALABILITY:
- Database indexes for performance
- Efficient query design
- Modular architecture for easy expansion

================================================================================
14. KEY ASSESSMENT POINTS TO EMPHASIZE
================================================================================

TECHNICAL SKILLS DEMONSTRATED:
1. Database Design: Proper normalization and relationships
2. Transaction Management: ACID compliance for critical operations
3. API Design: RESTful principles and consistent interface
4. Error Handling: Comprehensive error management
5. Security: SQL injection prevention and input validation
6. Performance: Database optimization and efficient queries
7. Code Organization: Clean architecture and separation of concerns

BUSINESS UNDERSTANDING:
1. Inventory Management: Real-world business requirements
2. Data Integrity: Preventing overselling and data corruption
3. Audit Trail: Compliance and debugging capabilities
4. User Experience: Flexible filtering and search capabilities

PROFESSIONAL PRACTICES:
1. Documentation: Comprehensive README and code comments
2. Testing: Postman collection and test scenarios
3. Version Control: Git repository structure
4. Environment Management: Configuration separation

================================================================================
15. COMMON INTERVIEW QUESTIONS & ANSWERS
================================================================================

Q: Why did you use transactions for inventory management?
A: Inventory updates require atomicity - both the inventory record and product stock must update together. If either fails, both should rollback to prevent data inconsistency and overselling.

Q: How does your filtering system work?
A: The system uses conditional query building. For tag filtering, I use a subquery to find products with specific tags, then aggregate all tags for the result. This approach is more efficient than complex HAVING clauses.

Q: Why separate inventory table instead of just updating product stock?
A: The inventory table provides an audit trail of all stock movements, which is essential for business compliance, debugging discrepancies, and understanding stock history.

Q: How do you prevent SQL injection?
A: I use Knex.js parameterized queries throughout the application. All user input is properly escaped and validated before database operations.

Q: What would you do to scale this system?
A: Add caching (Redis), implement pagination for large datasets, add database read replicas, implement rate limiting, and consider microservices architecture for larger scale.

================================================================================
END OF CODE EXPLANATION
================================================================================

This system demonstrates production-ready Node.js development with proper
database design, transaction management, security measures, and professional
code organization. Every component serves a specific purpose and follows
industry best practices.
